#!/usr/bin/env python3
import matplotlib.pyplot as plt
import sys, re, math, argparse, tempfile, os, random
import numpy as np

def parse_arguments():
  p = argparse.ArgumentParser(description='monte-carlo-integration')
  p.add_argument('seed', type=int)
  p.add_argument('nsteps', type=int)
  p.add_argument('nstep_print', type=int)
  p.add_argument('-s','--hide_table',action='store_true',default=False,
                  help='show table of values')
  return p.parse_args()
  
  
def print_monte_carlo(curr_step, n, curr_est, s):
  print("{}\t{:.6f}\t{:.6f}\t{:.6f}".format(curr_step, curr_est, math.pi-curr_est, s))
  
def plot_monte_carlo(n, est_pi, s):
  plt.plot(range(n), est_pi, label='estimated pi')
  plt.plot(range(n), s, label='standard error')

  plt.title('Monte Carlo Integration') 
  plt.xlabel('numer of iterations')
  plt.ylabel('value of est_pi and s')
  plt.legend()
  plt.grid(True)
  plt.show()


if __name__ == '__main__':
  args = parse_arguments()
  
  random.seed = args.seed
  a_c = 0
  a_s = 0
  est_pi_list = list()
  s_list = list()
  
    
  for i in range(args.nsteps):
    x = random.uniform(0.0, 1.0)
    y = random.uniform(0.0, 1.0)
    
    if math.sqrt((x-0.5)**2 + (y-0.5)**2) < 0.5:
      a_c += 1 
    a_s += 1
      
    curr_est = 4 * a_c / a_s
    est_pi_list.append(curr_est)
    p = a_c / a_s
    q = 1 - p
    s = 4 * math.sqrt((p * q) / args.nsteps)
    s_list.append(s)
    
    if (i % args.nstep_print == 0 and not args.hide_table):
      print_monte_carlo(i+1, args.nsteps, curr_est, s)
      
  if not args.hide_table:
    print_monte_carlo(args.nsteps, args.nsteps, curr_est, s)
  plot_monte_carlo(args.nsteps, est_pi_list, s_list)
        
    
    
    